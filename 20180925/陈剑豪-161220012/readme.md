﻿﻿﻿﻿﻿﻿﻿﻿﻿设计思想==>#对象首先所有生物体，包括葫芦娃，爷爷，蝎子精，蛇精，小喽啰都属于生物体对象，封装在一个Creature包中。接着本次由于引入了一个二维空间的概念，所以直接将二维空间看做一个对象Space，它拥有固有属性空间的大小，空间的内容（二维数组实现），并设计为静态成员，对应现实中空间唯一的概念，使所有生物处于同一维度。例如：        public class Space{    private static int[][] space;    private int sizeofspace;    ……    }对应地，为每个生物体对象添加了对应于空间中坐标的属性，即二维坐标，例如：    public class Creature{    private int row;    private int column;    ……    }    >#方法在保留了上一次作业葫芦娃的设计以及排序方法基础上，添加了其他生物对象，并且这些生物对象都拥有报名字的能力reportName，还有一种站在二维空间上某一处的行为standOnMap，即更新自身的二维坐标属性，并将对应的二维空间中的位置填充为自身对应编号。例如：    public void standOnMap(int i,int j)    {        row=i;        column=j;        Space.space[i][j]=1;    }    // 0代表没有站生物    // 1代表站了爷爷    // 2,3,4,5,6,7,8代表站了大娃、二娃、三娃、四娃、五娃、六娃、七娃    // 9代表站了蛇精    // 10代表站了蝎子精    // 11代表站了小喽啰对于Space类，提供六个方法：1.重置空间remove，即简单地将空间中所有位置的信息清零。2.长蛇阵:    public void singlelineBattleArray(CalabashBrothers[] brothers,int row,int column)//一字长蛇阵    {        for(int i=row;i<row+7;i++)        {            brothers[i-row].standOnMap(i,column);        }    }对外提供接口为葫芦兄弟这个对象，长蛇阵需要摆放的起始位置。内部实现含义为指导葫芦兄弟调用自身行为standOnMap站在Space提供给他们的位置上，就形成了长蛇阵。3.鹤翼阵：    public void craneBattleArray(ScorpionMonster scorpionMonster,Underlings[] underlings,int row,int column)// 鹤翼阵    {        scorpionMonster.standOnMap(row,column);        for(int k=0;k<(underlings.length/2);k++)        {            underlings[k*2].standOnMap(row-k-1,column+k+1);            underlings[k*2+1].standOnMap(row+k+1,column+k+1);        }    }对外提供接口为蝎子精和小喽啰这两个对象，以及蝎子精的位置，小喽啰的位置随蝎子精的位置决定，同样是调用生物自身行为standOnMap来实现阵法的形成。4.雁行阵，与鹤翼阵类似。5.指定位置摆放爷爷和蛇精，直接调用生物行为standOnMap即可。6.展示地图上站位情况display，根据二维数组中的值调用各个生物的报上姓名行为reportName。例如        switch(space[i][j]) {    case 1:              Grandparent.reportName();              break;    ……    ｝>#优点通过将Space看成一个对象，所有的二维空间中的点都是对象的属性，并利用所有生物与地图的交互接口，使得阵法的排列几乎只需要关心Space类本身即可，避免了繁杂的细节和生物间的差异性。>#最终效果展现![avatar](https://github.com/161220012/cjh-house/blob/master/huluwa.jpg)